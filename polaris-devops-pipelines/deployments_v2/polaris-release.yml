---
trigger: none
pr: none

resources:
  pipelines:
    - pipeline: PolarisBuild
      source: Polaris - Build
      trigger:
        branches:
          include:
            - refs/heads/main
        stages:
          - Publish_Artifacts

variables:
  - group: kv-dev-terraform
  - group: kv-qa-terraform
  - group: kv-prod-terraform
  - group: polaris-global
  - group: polaris-status-check-endpoints
    
stages:
  # DETERMINE CHANGES - GIT DIFF FOR ALL 3 ENVIRONMENTS AND PREPARE RECORD OF CHANGES
  - stage: Determine_Changes
    displayName: Determine Changes
    jobs:
      - job: Generate_Diff
        pool:
          name: $(dev-build-agent)
        steps:
          - template: tasks/task_determine-changes.yml
  
  ################################# DEV ##############################################          
  # QUEUE PIPELINE IF ANOTHER ONE BASED ON THIS BUILD DEFINITION ID IS ALREADY RUNNING
  - stage: Wait_For_Running_Releases_DEV
    displayName: Assess Queue
    dependsOn: Determine_Changes
    condition: succeeded()
    variables:
      runTerraformDEV: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_TERRAFORM_DEV']]
      runCodebaseDEV: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_CODEBASE_DEV']]
    jobs:
      # Job to wait for running builds
      - deployment: waitForRunningBuildsDev
        condition: or(eq(variables.runTerraformDEV, 'true'),eq(variables.runCodebaseDEV, 'true'))
        displayName: 'Checking for Running Releases'
        timeoutInMinutes: 240
        pool:
          vmImage: 'windows-latest'
        continueOnError: false  # 'true' if future jobs should run even if this job fails; defaults to 'false'
        environment: "Dev"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_wait-for-running-releases.yml
                  parameters:
                    devOpsPatToken: "$(devops-pat-token)"
              
  # DEV: BEGIN DEPLOYMENT, TERRAFORM AND THEN CODEBASE, IF CHANGES FOUND  
  - stage: Deploy_DEV
    displayName: Deploy > DEV
    condition: succeeded()
    variables:
      runTerraformDEV: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_TERRAFORM_DEV']]
      runCodebaseDEV: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_CODEBASE_DEV']]
    dependsOn: 
      - Determine_Changes
      - Wait_For_Running_Releases_DEV
    pool:
      name: $(dev-build-agent)
    jobs:
      - deployment: LogStart
        displayName: Log Start
        condition: and(succeeded(), or(eq(variables.runTerraformDEV, 'true'),eq(variables.runTerraformDEV, 'true')))
        environment: "Dev"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_log-start-deployment.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "DEV"
                    targetName: "CI Deployment"
                    appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
                    
      - deployment: LogStartTerraform
        condition: and(succeeded(), eq(variables.runTerraformDEV, 'true'))
        dependsOn: LogStart
        displayName: Log Terraform Start
        environment: "Dev"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_log-start-deployment.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "DEV"
                    targetName: "Terraform CI Deployment"
                    appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
                    
      - deployment: ApplyNetworkingTerraform
        condition: and(succeeded(), eq(variables.runTerraformDEV, 'true'))
        displayName: Apply Networking Terraform
        dependsOn: LogStartTerraform
        environment: "Dev"
        workspace:
          clean: all
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_apply-terraform.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetTerraformArtifact: "networking-terraform-files"
                    targetLabel: "DEV"
                    targetName: "Networking Terraform CI Deployment"
                    targetPlanName: "dev"
                    appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
                    terraformStorageAccount: $(dev-terraform-storage-account)
                    terraformContainerName: $(networking-terraform-container-name)
                    terraformStateKey: $(terraform-key)
                    terraformStateAccessKey: $(cpsdevstorageterraform-key1)
                    armClientId: $(innovation-development-spn-client-id)
                    armClientSecret: $(innovation-development-spn-secret)
                    armTenantId: $(innovation-development-spn-tenant-id)
                    armSubscriptionId: $(innovation-development-subscription-id)

      - deployment: ApplyPipelineTerraform
        condition: and(succeeded(), eq(variables.runTerraformDEV, 'true'))
        dependsOn: ApplyNetworkingTerraform
        displayName: Apply Pipeline Terraform
        environment: "Dev"
        workspace:
          clean: all
        strategy:
          runOnce:
            deploy:
              steps:      
                - template: tasks/task_apply-terraform.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetTerraformArtifact: "pipeline-terraform-files"
                    targetLabel: "DEV"
                    targetName: "Pipeline Terraform CI Deployment"
                    targetPlanName: "dev"
                    appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
                    terraformStorageAccount: $(dev-terraform-storage-account)
                    terraformContainerName: $(pipeline-terraform-container-name)
                    terraformStateKey: $(terraform-key)
                    terraformStateAccessKey: $(cpsdevstorageterraform-key1)
                    armClientId: $(innovation-development-spn-client-id)
                    armClientSecret: $(innovation-development-spn-secret)
                    armTenantId: $(innovation-development-spn-tenant-id)
                    armSubscriptionId: $(innovation-development-subscription-id)

      - deployment: ApplyPipelineEventsTerraform
        condition: and(succeeded(), eq(variables.runTerraformDEV, 'true'))
        dependsOn: ApplyNetworkingTerraform
        displayName: Apply Pipeline Events Terraform
        environment: "Dev"
        workspace:
          clean: all
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_apply-terraform.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetTerraformArtifact: "pipeline-events-terraform-files"
                    targetLabel: "DEV"
                    targetName: "Pipeline Events Terraform CI Deployment"
                    targetPlanName: "dev"
                    appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
                    terraformStorageAccount: $(dev-terraform-storage-account)
                    terraformContainerName: $(pipeline-events-terraform-container-name)
                    terraformStateKey: $(terraform-key)
                    terraformStateAccessKey: $(cpsdevstorageterraform-key1)
                    armClientId: $(innovation-development-spn-client-id)
                    armClientSecret: $(innovation-development-spn-secret)
                    armTenantId: $(innovation-development-spn-tenant-id)
                    armSubscriptionId: $(innovation-development-subscription-id)
                
      - deployment: UpdatePipelineComponentAppKeys
        dependsOn: ApplyPipelineTerraform
        displayName: Update Component Keys
        condition: and(succeeded(), eq(variables.runTerraformDEV, 'true'))
        environment: "Dev"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_update-app-keys-in-pipeline-components.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "DEV"
                    targetName: "Pipeline Terraform CI Deployment"
                    targetSuffix: "-dev"
                    appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
                    armClientId: $(innovation-development-spn-client-id)
                    armClientSecret: $(innovation-development-spn-secret)
                    armTenantId: $(innovation-development-spn-tenant-id)
                    armSubscriptionId: $(innovation-development-subscription-id)
                  
      - deployment: ApplyUITerraform
        condition: and(succeeded(), eq(variables.runTerraformDEV, 'true'))
        dependsOn: UpdatePipelineComponentAppKeys
        displayName: Apply UI Terraform
        environment: "Dev"
        workspace:
          clean: all
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_apply-terraform.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetTerraformArtifact: "ui-terraform-files"
                    targetLabel: "DEV"
                    targetName: "UI Terraform CI Deployment"
                    targetPlanName: "dev"
                    appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
                    terraformStorageAccount: $(dev-terraform-storage-account)
                    terraformContainerName: $(ui-terraform-container-name)
                    terraformStateKey: $(terraform-key)
                    terraformStateAccessKey: $(cpsdevstorageterraform-key1)
                    armClientId: $(innovation-development-spn-client-id)
                    armClientSecret: $(innovation-development-spn-secret)
                    armTenantId: $(innovation-development-spn-tenant-id)
                    armSubscriptionId: $(innovation-development-subscription-id)

      - deployment: ApplyUIEventsTerraform
        condition: and(succeeded(), eq(variables.runTerraformDEV, 'true'))
        dependsOn: ApplyUITerraform
        displayName: Apply UI Events Terraform
        environment: "Dev"
        workspace:
          clean: all
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_apply-terraform.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetTerraformArtifact: "ui-events-terraform-files"
                    targetLabel: "DEV"
                    targetName: "UI Events Terraform CI Deployment"
                    targetPlanName: "dev"
                    appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
                    terraformStorageAccount: $(dev-terraform-storage-account)
                    terraformContainerName: $(ui-events-terraform-container-name)
                    terraformStateKey: $(terraform-key)
                    terraformStateAccessKey: $(cpsdevstorageterraform-key1)
                    armClientId: $(innovation-development-spn-client-id)
                    armClientSecret: $(innovation-development-spn-secret)
                    armTenantId: $(innovation-development-spn-tenant-id)
                    armSubscriptionId: $(innovation-development-subscription-id)

      - deployment: SetLogAnalyticsArchivalPeriods
        condition: and(succeeded(), eq(variables.runTerraformDEV, 'true'))
        dependsOn: ApplyUITerraform
        displayName: Update Analytics Archival Periods
        environment: "Dev"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_set-log-analytics-archival-periods.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "DEV"
                    targetName: "UI Terraform CI Deployment"
                    targetSuffix: "-dev"
                    appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
                    armClientId: $(innovation-development-spn-client-id)
                    armClientSecret: $(innovation-development-spn-secret)
                    armTenantId: $(innovation-development-spn-tenant-id)
                    armSubscriptionId: $(innovation-development-subscription-id)
                    logRetentionTime: $(log-retention-time)
                    totalLogRetentionTime: $(total-log-retention-time)
                  
      - deployment: LogResultTerraformEnded
        condition: and(succeeded(), eq(variables.runTerraformDEV, 'true'))
        displayName: Log Terraform End
        dependsOn:
          - ApplyPipelineTerraform
          - ApplyPipelineEventsTerraform
          - UpdatePipelineComponentAppKeys
          - ApplyUITerraform
          - ApplyUIEventsTerraform
          - SetLogAnalyticsArchivalPeriods
          - ApplyNetworkingTerraform
        environment: "Dev"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_log-result-deployment.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "DEV"
                    targetName: "Terraform CI Deployment"
                    appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
                    devOpsPatToken: "$(devops-pat-token)"
                    
      - deployment: LogStartCodebase
        condition: and(succeeded(), eq(variables.runCodebaseDEV, 'true'))
        dependsOn: LogResultTerraformEnded
        displayName: Log Codebase Start
        environment: "Dev"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_log-start-deployment.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "DEV"
                    targetName: "Codebase CI Deployment"
                    appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
                    
      - job: StartPipelineSlots
        dependsOn: LogResultTerraformEnded
        condition: and(succeeded(), eq(variables.runCodebaseDEV, 'true'))
        strategy:
          matrix:
            Coordinator:
              Name: "Coordinator"
              AppServiceName: "fa-polaris-dev-coordinator"
            PDFGenerator:
              Name: "PDF Generator"
              AppServiceName: "fa-polaris-dev-pdf-generator"
        displayName: Start Staging1
        steps:
          - checkout: none
          - task: AzureAppServiceManage@0
            displayName: Start Slot
            inputs:
              Action: "Start Azure App Service"
              SpecifySlotOrASE: true
              Slot: "staging1"
              azureSubscription: $(dev-azure-subscription)
              ResourceGroupName: "rg-polaris-pipeline-dev"
              WebAppName: $(AppServiceName)

      - job: Start_UI_Slots
        dependsOn: LogResultTerraformEnded
        condition: and(succeeded(), eq(variables.runCodebaseDEV, 'true'))
        strategy:
          matrix:
            SPA:
              Name: "SPA"
              AppServiceName: "as-web-polaris-dev"
            PolarisGateway:
              Name: "Polaris Gateway"
              AppServiceName: "fa-polaris-dev-gateway"
        displayName: Start Staging1
        steps:
          - checkout: none
          - task: AzureAppServiceManage@0
            displayName: Start slot
            inputs:
              Action: "Start Azure App Service"
              SpecifySlotOrASE: true
              Slot: "staging1"
              azureSubscription: $(dev-azure-subscription)
              ResourceGroupName: "rg-polaris-dev"
              WebAppName: $(AppServiceName)

      - deployment: DeployCoordinator
        dependsOn: Start_Pipeline_Slots
        displayName: Deploy Coordinator
        condition: and(succeeded(), eq(variables.runCodebaseDEV, 'true'))
        environment: "Dev"
        workspace:
          clean: all
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_deploy-coordinator.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "DEV"
                    targetSuffix: "-dev"
                    appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
                    azureSubscription: $(dev-azure-subscription)

      - deployment: DeployPdfGenerator
        dependsOn: Start_Pipeline_Slots
        displayName: Deploy PDF Generator
        condition: and(succeeded(), eq(variables.runCodebaseDEV, 'true'))
        environment: "Dev"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_deploy-pdf-generator.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "DEV"
                    targetSuffix: "-dev"
                    appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
                    azureSubscription: $(dev-azure-subscription)

      - deployment: DeployTextGenerator
        dependsOn: Start_Pipeline_Slots
        displayName: Deploy Text Extractor
        condition: and(succeeded(), eq(variables.runCodebaseDEV, 'true'))
        environment: "Dev"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_deploy-text-extractor.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "DEV"
                    targetSuffix: "-dev"
                    appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
                    azureSubscription: $(dev-azure-subscription)

      - deployment: DeploySpa
        dependsOn: Start_UI_Slots
        displayName: Deploy SPA
        condition: and(succeeded(), eq(variables.runCodebaseDEV, 'true'))
        environment: "Dev"
        workspace:
          clean: all
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_deploy-spa.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "DEV"
                    targetSuffix: "-dev"
                    appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
                    azureSubscription: $(dev-azure-subscription)

      - deployment: DeployGateway
        dependsOn: Start_UI_Slots
        displayName: Deploy Gateway
        condition: and(succeeded(), eq(variables.runCodebaseDEV, 'true'))
        environment: "Dev"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_deploy-gateway.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "DEV"
                    targetSuffix: "-dev"
                    appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
                    azureSubscription: $(dev-azure-subscription)

      - deployment: LogResultCodebaseEnded
        condition: and(succeeded(), eq(variables.runCodebaseDEV, 'true'))
        displayName: Log Codebase End
        dependsOn:
          - DeployCoordinator
          - DeployPdfGenerator
          - DeployTextGenerator
          - DeploySpa
          - DeployGateway
        environment: "Dev"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_log-result-deployment.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "DEV"
                    targetName: "Codebase CI Deployment"
                    appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
                    devOpsPatToken: "$(devops-pat-token)"

      - deployment: LogResultEnded
        condition: and(succeeded(), or(eq(variables.runTerraformDEV, 'true'),eq(variables.runCodebaseDEV, 'true')))
        displayName: Log Deployment End
        dependsOn:
          - ApplyPipelineTerraform
          - ApplyPipelineEventsTerraform
          - UpdatePipelineComponentAppKeys
          - ApplyUITerraform
          - ApplyUIEventsTerraform
          - SetLogAnalyticsArchivalPeriods
          - ApplyNetworkingTerraform
          - DeployCoordinator
          - DeployPdfGenerator
          - DeployTextGenerator
          - DeploySpa
          - DeployGateway
        environment: "Dev"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_log-result-deployment.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "DEV"
                    targetName: "CI Deployment"
                    appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
                    devOpsPatToken: "$(devops-pat-token)"    

  # DEV: BEGIN SLOT SWAP PROCESS
  - stage: Swap_DEV
    displayName: Swap Slots > DEV
    dependsOn: 
      - Deploy_DEV
      - Determine_Changes
    variables:
      runCodebaseDEV: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_CODEBASE_DEV']]
    condition: succeeded()
    pool:
      name: $(dev-build-agent)
    jobs:
      - job: LogStart
        displayName: Log Start
        condition: and(succeeded(), eq(variables.runCodebaseDEV, 'true'))
        steps:
          - template: tasks/task_log-start.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "DEV"
              targetName: "Swap Polaris Codebase Slots"
              appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
          
      - job: Pause_Pipeline
        dependsOn: LogStart
        condition: and(succeeded(), eq(variables.runCodebaseDEV, 'true'))
        displayName: Pause for 2 mins
        steps:
          - template: tasks/task_pause-pipeline.yml

      - job: Start_Pipeline_Slots
        dependsOn: Pause_Pipeline
        condition: and(succeeded(), eq(variables.runCodebaseDEV, 'true'))
        strategy:
          matrix:
            Coordinator:
              Name: "Coordinator"
              AppServiceName: "fa-polaris-dev-coordinator"
            PDFGenerator:
              Name: "PDF Generator"
              AppServiceName: "fa-polaris-dev-pdf-generator"
        displayName: Start Staging1
        steps:
          - checkout: none
          - task: AzureAppServiceManage@0
            displayName: Start Slot
            inputs:
              Action: "Start Azure App Service"
              SpecifySlotOrASE: true
              Slot: "staging1"
              azureSubscription: $(dev-azure-subscription)
              ResourceGroupName: "rg-polaris-pipeline-dev"
              WebAppName: $(AppServiceName)

      - job: Start_UI_Slots
        dependsOn: Pause_Pipeline
        condition: and(succeeded(), eq(variables.runCodebaseDEV, 'true'))
        strategy:
          matrix:
            SPA:
              Name: "SPA"
              AppServiceName: "as-web-polaris-dev"
            PolarisGateway:
              Name: "Polaris Gateway"
              AppServiceName: "fa-polaris-dev-gateway"
        displayName: Start Staging1
        steps:
          - checkout: none
          - task: AzureAppServiceManage@0
            displayName: Start slot
            inputs:
              Action: "Start Azure App Service"
              SpecifySlotOrASE: true
              Slot: "staging1"
              azureSubscription: $(dev-azure-subscription)
              ResourceGroupName: "rg-polaris-dev"
              WebAppName: $(AppServiceName)

      - job: Swap_Pipeline_Slots
        dependsOn: Start_Pipeline_Slots
        condition: and(succeeded(), eq(variables.runCodebaseDEV, 'true'))
        strategy:
          matrix:
            Coordinator:
              Name: "Coordinator"
              AppServiceName: "fa-polaris-dev-coordinator"
            PDFGenerator:
              Name: "PDF Generator"
              AppServiceName: "fa-polaris-dev-pdf-generator"
        displayName: Swap
        steps:
          - checkout: none
          - task: AzureAppServiceManage@0
            displayName: Swap slot
            inputs:
              action: "Swap Slots"
              sourceSlot: "staging1"
              azureSubscription: $(dev-azure-subscription)
              resourceGroupName: "rg-polaris-pipeline-dev"
              webAppName: $(AppServiceName)
              PreserveVnet: true

      - job: Swap_UI_Slots
        dependsOn: Start_UI_Slots
        condition: and(succeeded(), eq(variables.runCodebaseDEV, 'true'))
        strategy:
          matrix:
            SPA:
              Name: "SPA"
              AppServiceName: "as-web-polaris-dev"
            PolarisGateway:
              Name: "Polaris Gateway"
              AppServiceName: "fa-polaris-dev-gateway"
        displayName: Swap
        steps:
          - checkout: none
          - task: AzureAppServiceManage@0
            displayName: Swap slot
            inputs:
              action: "Swap Slots"
              sourceSlot: "staging1"
              azureSubscription: $(dev-azure-subscription)
              resourceGroupName: "rg-polaris-dev"
              webAppName: $(AppServiceName)
              PreserveVnet: true

      - job: LogResult
        condition: and(succeeded(), eq(variables.runCodebaseDEV, 'true'))
        dependsOn:
          - Swap_Pipeline_Slots
          - Swap_UI_Slots
        steps:
          - template: tasks/task_log-result.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "Dev"
              targetName: "Swap Polaris Codebase Slots"
              appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
              devOpsPatToken: "$(devops-pat-token)"

  # DEV: CHECK FOR VALID STATUS RESPONSES FROM /API/STATUS ENDPOINTS IN SWAPPED APPS
  - stage: Check_DEV
    displayName: Status Checks > DEV
    dependsOn: 
      - Swap_DEV
      - Determine_Changes
    condition: succeeded()
    variables:
      runTerraformDEV: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_TERRAFORM_DEV']]
      runCodebaseDEV: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_CODEBASE_DEV']]
    pool:
      name: $(dev-build-agent)
    jobs:
      - job: LogStart
        displayName: Log Start
        condition: and(succeeded(), or(eq(variables.runTerraformDEV, 'true'),eq(variables.runCodebaseDEV, 'true')))
        steps:
          - template: tasks/task_log-start.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "DEV"
              targetName: "Status Checks"
              appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
        
      - job: GetStatusURIs
        dependsOn: LogStart
        condition: and(succeeded(), or(eq(variables.runTerraformDEV, 'true'),eq(variables.runCodebaseDEV, 'true')))
        steps:
          - template: tasks/task_check-statuses.yml
            parameters:
              targetBuild: PolarisBuild
              targetSuffix: "-dev"
              targetLabel: "DEV"
              statusCheckMethod: $(status-check-method)
              statusCheckRetries: $(status-check-retries)
              statusCheckDelaySeconds: $(status-check-delay-seconds)
              statusCheckTimeoutSeconds: $(status-check-timeout-seconds)
              armClientId: $(innovation-development-spn-client-id)
              armClientSecret: $(innovation-development-spn-secret)
              armTenantId: $(innovation-development-spn-tenant-id)
              armSubscriptionId: $(innovation-development-subscription-id)
          
      - job: LogResult
        condition: and(succeeded(), or(eq(variables.runTerraformDEV, 'true'),eq(variables.runCodebaseDEV, 'true')))
        dependsOn:
          - LogStart
          - GetStatusURIs
          - CheckCoordinator
          - CheckPDFGenerator
          - CheckTextExtractor
          - CheckGateway
          - CheckSPA
        steps:
          - template: tasks/task_log-result.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "Dev"
              targetName: "Status Checks"
              appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
              devOpsPatToken: "$(devops-pat-token)"
            
  # DEV: SAVE COMMIT REPORTS TO THE PIPELINE REPO          
  - stage: Create_Commit_Report_DEV
    displayName: Save Report > DEV
    dependsOn: 
      - Check_DEV
      - Determine_Changes
    condition: succeeded()
    variables:
      runTerraformDEV: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_TERRAFORM_DEV']]
      runCodebaseDEV: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_CODEBASE_DEV']]
    pool:
      name: $(dev-build-agent)
    jobs:
      - job: LogStart
        displayName: Log Start
        condition: and(succeeded(), or(eq(variables.runTerraformDEV, 'true'),eq(variables.runCodebaseDEV, 'true')))
        steps:
          - template: tasks/task_log-start.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "DEV"
              targetName: "Create Commit Report"
              appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"

      - job: CreateCommitReport
        dependsOn: LogStart
        condition: and(succeeded(), or(eq(variables.runTerraformDEV, 'true'),eq(variables.runCodebaseDEV, 'true')))
        steps:
          - template: tasks/task_create-commit-report.yml
            parameters:
              targetLabel: "DEV"
              targetLabelLower: "dev"

      - job: LogResult
        condition: and(succeeded(), or(eq(variables.runTerraformDEV, 'true'),eq(variables.runCodebaseDEV, 'true')))
        dependsOn:
          - LogStart
          - CreateCommitReport
        steps:
          - template: tasks/task_log-result.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "Dev"
              targetName: "Create Commit Report"
              appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
              devOpsPatToken: "$(devops-pat-token)"
  
  # DEV: MOVE THE GITHUB TAG TO THE TIP OF MAIN          
  - stage: Update_GitHub_Tag_DEV
    displayName: Update Tag > DEV
    dependsOn: 
      - Create_Commit_Report_DEV
      - Determine_Changes
    condition: succeeded()
    variables:
      runTerraformDEV: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_TERRAFORM_DEV']]
      runCodebaseDEV: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_CODEBASE_DEV']]
    pool:
      name: $(dev-build-agent)
    jobs:
      - job: LogStart
        displayName: Log Start
        condition: and(succeeded(), or(eq(variables.runTerraformDEV, 'true'),eq(variables.runCodebaseDEV, 'true')))
        steps:
          - template: tasks/task_log-start.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "DEV"
              targetName: "Update GitHub Tag"
              appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
              
      - job: UpdateGithubTag
        dependsOn: LogStart
        steps:
          - template: tasks/task_update-github-tag.yml
            parameters:
              targetLabel: "DEV"

      - job: LogResult
        condition: and(succeeded(), or(eq(variables.runTerraformDEV, 'true'),eq(variables.runCodebaseDEV, 'true')))
        dependsOn:
          - LogStart
          - UpdateGitHubTag
        steps:
          - template: tasks/task_log-result.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "Dev"
              targetName: "Update GitHub Tag"
              appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
              devOpsPatToken: "$(devops-pat-token)"
  
  #DEV: RUN E2E TESTS AS FINAL CHECKS          
  - stage: Run_e2e_Tests_DEV
    displayName: e2e tests > DEV
    dependsOn: 
      - Update_GitHub_Tag_DEV
      - Determine_Changes
    condition: succeeded()
    variables:
      runTerraformDEV: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_TERRAFORM_DEV']]
      runCodebaseDEV: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_CODEBASE_DEV']]
    pool:
      name: $(dev-build-agent)
    jobs:
      - job: LogStart
        displayName: Log Start
        condition: and(succeeded(), or(eq(variables.runTerraformDEV, 'true'),eq(variables.runCodebaseDEV, 'true')))
        steps:
          - template: tasks/task_log-start.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "DEV"
              targetName: "e2e Tests"
              appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"

      - job: RunE2ETests
        condition: and(succeeded(), or(eq(variables.runTerraformDEV, 'true'),eq(variables.runCodebaseDEV, 'true')))
        steps:
          - template: tasks/task_run-e2e-tests.yml
            parameters:
              targetLabel: "DEV"
              buildDefinitionId: 129
              devOpsPatToken: "$(devops-pat-token)"
      
      - job: LogResult
        condition: and(succeeded(), or(eq(variables.runTerraformDEV, 'true'),eq(variables.runCodebaseDEV, 'true')))
        dependsOn:
          - LogStart
          - RunE2eTests
        steps:
          - template: tasks/task_log-result.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "Dev"
              targetName: "e2e Tests"
              appInsightsKey: "$(innovation-development-app-insights-instrumentation-key)"
              devOpsPatToken: "$(devops-pat-token)"
  
  ################################# QA ###############################################          
  # QUEUE PIPELINE IF ANOTHER ONE BASED ON THIS BUILD DEFINITION ID IS ALREADY RUNNING
  - stage: Wait_For_Running_Releases_QA
    displayName: Assess Queue
    dependsOn: 
      - Determine_Changes
      - Run_e2e_Tests_DEV
    condition: succeeded()
    variables:
      runTerraformQA: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_TERRAFORM_QA']]
      runCodebaseQA: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_CODEBASE_QA']]
    jobs:
      # Job to wait for running builds
      - deployment: waitForRunningBuildsDev
        condition: or(eq(variables.runTerraformQA, 'true'),eq(variables.runCodebaseQA, 'true'))
        displayName: 'Checking for Running Releases'
        timeoutInMinutes: 240
        pool:
          vmImage: 'windows-latest'
        continueOnError: false  # 'true' if future jobs should run even if this job fails; defaults to 'false'
        environment: "QA"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_wait-for-running-releases.yml
                  parameters:
                    devOpsPatToken: "$(devops-pat-token)"

  # QA: BEGIN DEPLOYMENT, TERRAFORM AND THEN CODEBASE, IF CHANGES FOUND  
  - stage: Deploy_QA
    displayName: Deploy > QA
    condition: succeeded()
    variables:
      runTerraformQA: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_TERRAFORM_QA']]
      runCodebaseQA: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_CODEBASE_QA']]
    dependsOn:
      - Determine_Changes
      - Wait_For_Running_Releases_QA
    pool:
      name: $(qa-build-agent)
    jobs:
      - deployment: LogStart
        displayName: Log Start
        condition: and(succeeded(), or(eq(variables.runTerraformQA, 'true'),eq(variables.runTerraformQA, 'true')))
        environment: "QA"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_log-start-deployment.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "QA"
                    targetName: "CI Deployment"
                    appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"

      - deployment: LogStartTerraform
        condition: and(succeeded(), eq(variables.runTerraformQA, 'true'))
        dependsOn: LogStart
        displayName: Log Terraform Start
        environment: "QA"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_log-start-deployment.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "QA"
                    targetName: "Terraform CI Deployment"
                    appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"

      - deployment: ApplyNetworkingTerraform
        condition: and(succeeded(), eq(variables.runTerraformQA, 'true'))
        displayName: Apply Networking Terraform
        dependsOn: LogStartTerraform
        environment: "QA"
        workspace:
          clean: all
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_apply-terraform.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetTerraformArtifact: "networking-terraform-files"
                    targetLabel: "QA"
                    targetName: "Networking Terraform CI Deployment"
                    targetPlanName: "qa"
                    appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"
                    terraformStorageAccount: $(qa-terraform-storage-account)
                    terraformContainerName: $(networking-terraform-container-name)
                    terraformStateKey: $(terraform-key)
                    terraformStateAccessKey: $(cpsqastorageterraform-key1)
                    armClientId: $(innovation-qa-spn-client-id)
                    armClientSecret: $(innovation-qa-spn-secret)
                    armTenantId: $(innovation-qa-spn-tenant-id)
                    armSubscriptionId: $(innovation-qa-subscription-id)

      - deployment: ApplyPipelineTerraform
        condition: and(succeeded(), eq(variables.runTerraformQA, 'true'))
        dependsOn: ApplyNetworkingTerraform
        displayName: Apply Pipeline Terraform
        environment: "QA"
        workspace:
          clean: all
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_apply-terraform.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetTerraformArtifact: "pipeline-terraform-files"
                    targetLabel: "QA"
                    targetName: "Pipeline Terraform CI Deployment"
                    targetPlanName: "qa"
                    appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"
                    terraformStorageAccount: $(qa-terraform-storage-account)
                    terraformContainerName: $(pipeline-terraform-container-name)
                    terraformStateKey: $(terraform-key)
                    terraformStateAccessKey: $(cpsqastorageterraform-key1)
                    armClientId: $(innovation-qa-spn-client-id)
                    armClientSecret: $(innovation-qa-spn-secret)
                    armTenantId: $(innovation-qa-spn-tenant-id)
                    armSubscriptionId: $(innovation-qa-subscription-id)

      - deployment: ApplyPipelineEventsTerraform
        condition: and(succeeded(), eq(variables.runTerraformQA, 'true'))
        dependsOn: ApplyNetworkingTerraform
        displayName: Apply Pipeline Events Terraform
        environment: "QA"
        workspace:
          clean: all
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_apply-terraform.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetTerraformArtifact: "pipeline-events-terraform-files"
                    targetLabel: "QA"
                    targetName: "Pipeline Events Terraform CI Deployment"
                    targetPlanName: "qa"
                    appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"
                    terraformStorageAccount: $(qa-terraform-storage-account)
                    terraformContainerName: $(pipeline-events-terraform-container-name)
                    terraformStateKey: $(terraform-key)
                    terraformStateAccessKey: $(cpsqastorageterraform-key1)
                    armClientId: $(innovation-qa-spn-client-id)
                    armClientSecret: $(innovation-qa-spn-secret)
                    armTenantId: $(innovation-qa-spn-tenant-id)
                    armSubscriptionId: $(innovation-qa-subscription-id)

      - deployment: UpdatePipelineComponentAppKeys
        dependsOn: ApplyPipelineTerraform
        displayName: Update Component Keys
        condition: and(succeeded(), eq(variables.runTerraformQA, 'true'))
        environment: "QA"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_update-app-keys-in-pipeline-components.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "QA"
                    targetName: "Pipeline Terraform CI Deployment"
                    targetSuffix: "-qa"
                    appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"
                    armClientId: $(innovation-qa-spn-client-id)
                    armClientSecret: $(innovation-qa-spn-secret)
                    armTenantId: $(innovation-qa-spn-tenant-id)
                    armSubscriptionId: $(innovation-qa-subscription-id)

      - deployment: ApplyUITerraform
        condition: and(succeeded(), eq(variables.runTerraformQA, 'true'))
        dependsOn: UpdatePipelineComponentAppKeys
        displayName: Apply UI Terraform
        environment: "QA"
        workspace:
          clean: all
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_apply-terraform.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetTerraformArtifact: "ui-terraform-files"
                    targetLabel: "QA"
                    targetName: "UI Terraform CI Deployment"
                    targetPlanName: "qa"
                    appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"
                    terraformStorageAccount: $(qa-terraform-storage-account)
                    terraformContainerName: $(ui-terraform-container-name)
                    terraformStateKey: $(terraform-key)
                    terraformStateAccessKey: $(cpsqastorageterraform-key1)
                    armClientId: $(innovation-qa-spn-client-id)
                    armClientSecret: $(innovation-qa-spn-secret)
                    armTenantId: $(innovation-qa-spn-tenant-id)
                    armSubscriptionId: $(innovation-qa-subscription-id)

      - deployment: ApplyUIEventsTerraform
        condition: and(succeeded(), eq(variables.runTerraformQA, 'true'))
        dependsOn: ApplyUITerraform
        displayName: Apply UI Events Terraform
        environment: "QA"
        workspace:
          clean: all
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_apply-terraform.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetTerraformArtifact: "ui-events-terraform-files"
                    targetLabel: "QA"
                    targetName: "UI Events Terraform CI Deployment"
                    targetPlanName: "qa"
                    appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"
                    terraformStorageAccount: $(qa-terraform-storage-account)
                    terraformContainerName: $(ui-events-terraform-container-name)
                    terraformStateKey: $(terraform-key)
                    terraformStateAccessKey: $(cpsqastorageterraform-key1)
                    armClientId: $(innovation-qa-spn-client-id)
                    armClientSecret: $(innovation-qa-spn-secret)
                    armTenantId: $(innovation-qa-spn-tenant-id)
                    armSubscriptionId: $(innovation-qa-subscription-id)

      - deployment: SetLogAnalyticsArchivalPeriods
        condition: and(succeeded(), eq(variables.runTerraformQA, 'true'))
        dependsOn: ApplyUITerraform
        displayName: Update Analytics Archival Periods
        environment: "QA"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_set-log-analytics-archival-periods.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "QA"
                    targetName: "UI Terraform CI Deployment"
                    targetSuffix: "-qa"
                    appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"
                    armClientId: $(innovation-qa-spn-client-id)
                    armClientSecret: $(innovation-qa-spn-secret)
                    armTenantId: $(innovation-qa-spn-tenant-id)
                    armSubscriptionId: $(innovation-qa-subscription-id)
                    logRetentionTime: $(log-retention-time)
                    totalLogRetentionTime: $(total-log-retention-time)

      - deployment: LogResultTerraformEnded
        condition: and(succeeded(), eq(variables.runTerraformQA, 'true'))
        displayName: Log Terraform End
        dependsOn:
          - ApplyPipelineTerraform
          - ApplyPipelineEventsTerraform
          - UpdatePipelineComponentAppKeys
          - ApplyUITerraform
          - ApplyUIEventsTerraform
          - SetLogAnalyticsArchivalPeriods
          - ApplyNetworkingTerraform
        environment: "QA"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_log-result-deployment.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "QA"
                    targetName: "Terraform CI Deployment"
                    appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"
                    devOpsPatToken: "$(devops-pat-token)"

      - deployment: LogStartCodebase
        condition: and(succeeded(), eq(variables.runCodebaseQA, 'true'))
        dependsOn: LogResultTerraformEnded
        displayName: Log Codebase Start
        environment: "QA"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_log-start-deployment.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "QA"
                    targetName: "Codebase CI Deployment"
                    appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"

      - job: StartPipelineSlots
        dependsOn: LogResultTerraformEnded
        condition: and(succeeded(), eq(variables.runCodebaseQA, 'true'))
        strategy:
          matrix:
            Coordinator:
              Name: "Coordinator"
              AppServiceName: "fa-polaris-qa-coordinator"
            PDFGenerator:
              Name: "PDF Generator"
              AppServiceName: "fa-polaris-qa-pdf-generator"
        displayName: Start Staging1
        steps:
          - checkout: none
          - task: AzureAppServiceManage@0
            displayName: Start Slot
            inputs:
              Action: "Start Azure App Service"
              SpecifySlotOrASE: true
              Slot: "staging1"
              azureSubscription: $(qa-azure-subscription)
              ResourceGroupName: "rg-polaris-pipeline-qa"
              WebAppName: $(AppServiceName)

      - job: Start_UI_Slots
        dependsOn: LogResultTerraformEnded
        condition: and(succeeded(), eq(variables.runCodebaseQA, 'true'))
        strategy:
          matrix:
            SPA:
              Name: "SPA"
              AppServiceName: "as-web-polaris-qa"
            PolarisGateway:
              Name: "Polaris Gateway"
              AppServiceName: "fa-polaris-qa-gateway"
        displayName: Start Staging1
        steps:
          - checkout: none
          - task: AzureAppServiceManage@0
            displayName: Start slot
            inputs:
              Action: "Start Azure App Service"
              SpecifySlotOrASE: true
              Slot: "staging1"
              azureSubscription: $(qa-azure-subscription)
              ResourceGroupName: "rg-polaris-qa"
              WebAppName: $(AppServiceName)

      - deployment: DeployCoordinator
        dependsOn: Start_Pipeline_Slots
        displayName: Deploy Coordinator
        condition: and(succeeded(), eq(variables.runCodebaseQA, 'true'))
        environment: "QA"
        workspace:
          clean: all
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_deploy-coordinator.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "QA"
                    targetSuffix: "-qa"
                    appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"
                    azureSubscription: $(qa-azure-subscription)

      - deployment: DeployPdfGenerator
        dependsOn: Start_Pipeline_Slots
        displayName: Deploy PDF Generator
        condition: and(succeeded(), eq(variables.runCodebaseQA, 'true'))
        environment: "QA"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_deploy-pdf-generator.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "QA"
                    targetSuffix: "-qa"
                    appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"
                    azureSubscription: $(qa-azure-subscription)

      - deployment: DeployTextGenerator
        dependsOn: Start_Pipeline_Slots
        displayName: Deploy Text Extractor
        condition: and(succeeded(), eq(variables.runCodebaseQA, 'true'))
        environment: "QA"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_deploy-text-extractor.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "QA"
                    targetSuffix: "-qa"
                    appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"
                    azureSubscription: $(qa-azure-subscription)

      - deployment: DeploySpa
        dependsOn: Start_UI_Slots
        displayName: Deploy SPA
        condition: and(succeeded(), eq(variables.runCodebaseQA, 'true'))
        environment: "QA"
        workspace:
          clean: all
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_deploy-spa.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "QA"
                    targetSuffix: "-qa"
                    appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"
                    azureSubscription: $(qa-azure-subscription)

      - deployment: DeployGateway
        dependsOn: Start_UI_Slots
        displayName: Deploy Gateway
        condition: and(succeeded(), eq(variables.runCodebaseQA, 'true'))
        environment: "QA"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_deploy-gateway.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "QA"
                    targetSuffix: "-qa"
                    appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"
                    azureSubscription: $(qa-azure-subscription)

      - deployment: LogResultCodebaseEnded
        condition: and(succeeded(), eq(variables.runCodebaseQA, 'true'))
        displayName: Log Codebase End
        dependsOn:
          - DeployCoordinator
          - DeployPdfGenerator
          - DeployTextGenerator
          - DeploySpa
          - DeployGateway
        environment: "QA"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_log-result-deployment.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "QA"
                    targetName: "Codebase CI Deployment"
                    appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"
                    devOpsPatToken: "$(devops-pat-token)"

      - deployment: LogResultEnded
        condition: and(succeeded(), or(eq(variables.runTerraformQA, 'true'),eq(variables.runCodebaseQA, 'true')))
        displayName: Log Deployment End
        dependsOn:
          - ApplyPipelineTerraform
          - ApplyPipelineEventsTerraform
          - UpdatePipelineComponentAppKeys
          - ApplyUITerraform
          - ApplyUIEventsTerraform
          - SetLogAnalyticsArchivalPeriods
          - ApplyNetworkingTerraform
          - DeployCoordinator
          - DeployPdfGenerator
          - DeployTextGenerator
          - DeploySpa
          - DeployGateway
        environment: "QA"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_log-result-deployment.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "QA"
                    targetName: "CI Deployment"
                    appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"
                    devOpsPatToken: "$(devops-pat-token)"
  
  # QA: BEGIN SLOT SWAP PROCESS
  - stage: Swap_QA
    displayName: Swap Slots > QA
    dependsOn:
      - Deploy_QA
      - Determine_Changes
    variables:
      runCodebaseQA: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_CODEBASE_QA']]
    condition: succeeded()
    pool:
      name: $(qa-build-agent)
    jobs:
      - job: LogStart
        displayName: Log Start
        condition: and(succeeded(), eq(variables.runCodebaseQA, 'true'))
        steps:
          - template: tasks/task_log-start.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "QA"
              targetName: "Swap Polaris Codebase Slots"
              appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"

      - job: Pause_Pipeline
        dependsOn: LogStart
        condition: and(succeeded(), eq(variables.runCodebaseQA, 'true'))
        displayName: Pause for 2 mins
        steps:
          - template: tasks/task_pause-pipeline.yml

      - job: Start_Pipeline_Slots
        dependsOn: Pause_Pipeline
        condition: and(succeeded(), eq(variables.runCodebaseQA, 'true'))
        strategy:
          matrix:
            Coordinator:
              Name: "Coordinator"
              AppServiceName: "fa-polaris-qa-coordinator"
            PDFGenerator:
              Name: "PDF Generator"
              AppServiceName: "fa-polaris-qa-pdf-generator"
        displayName: Start Staging1
        steps:
          - checkout: none
          - task: AzureAppServiceManage@0
            displayName: Start Slot
            inputs:
              Action: "Start Azure App Service"
              SpecifySlotOrASE: true
              Slot: "staging1"
              azureSubscription: $(qa-azure-subscription)
              ResourceGroupName: "rg-polaris-pipeline-qa"
              WebAppName: $(AppServiceName)

      - job: Start_UI_Slots
        dependsOn: Pause_Pipeline
        condition: and(succeeded(), eq(variables.runCodebaseQA, 'true'))
        strategy:
          matrix:
            SPA:
              Name: "SPA"
              AppServiceName: "as-web-polaris-qa"
            PolarisGateway:
              Name: "Polaris Gateway"
              AppServiceName: "fa-polaris-qa-gateway"
        displayName: Start Staging1
        steps:
          - checkout: none
          - task: AzureAppServiceManage@0
            displayName: Start slot
            inputs:
              Action: "Start Azure App Service"
              SpecifySlotOrASE: true
              Slot: "staging1"
              azureSubscription: $(qa-azure-subscription)
              ResourceGroupName: "rg-polaris-qa"
              WebAppName: $(AppServiceName)

      - job: Swap_Pipeline_Slots
        dependsOn: Start_Pipeline_Slots
        condition: and(succeeded(), eq(variables.runCodebaseQA, 'true'))
        strategy:
          matrix:
            Coordinator:
              Name: "Coordinator"
              AppServiceName: "fa-polaris-qa-coordinator"
            PDFGenerator:
              Name: "PDF Generator"
              AppServiceName: "fa-polaris-qa-pdf-generator"
        displayName: Swap
        steps:
          - checkout: none
          - task: AzureAppServiceManage@0
            displayName: Swap slot
            inputs:
              action: "Swap Slots"
              sourceSlot: "staging1"
              azureSubscription: $(qa-azure-subscription)
              resourceGroupName: "rg-polaris-pipeline-qa"
              webAppName: $(AppServiceName)
              PreserveVnet: true

      - job: Swap_UI_Slots
        dependsOn: Start_UI_Slots
        condition: and(succeeded(), eq(variables.runCodebaseQA, 'true'))
        strategy:
          matrix:
            SPA:
              Name: "SPA"
              AppServiceName: "as-web-polaris-qa"
            PolarisGateway:
              Name: "Polaris Gateway"
              AppServiceName: "fa-polaris-qa-gateway"
        displayName: Swap
        steps:
          - checkout: none
          - task: AzureAppServiceManage@0
            displayName: Swap slot
            inputs:
              action: "Swap Slots"
              sourceSlot: "staging1"
              azureSubscription: $(qa-azure-subscription)
              resourceGroupName: "rg-polaris-qa"
              webAppName: $(AppServiceName)
              PreserveVnet: true

      - job: LogResult
        condition: and(succeeded(), eq(variables.runCodebaseQA, 'true'))
        dependsOn:
          - Swap_Pipeline_Slots
          - Swap_UI_Slots
        steps:
          - template: tasks/task_log-result.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "QA"
              targetName: "Swap Polaris Codebase Slots"
              appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"
              devOpsPatToken: "$(devops-pat-token)"

  # QA: CHECK FOR VALID STATUS RESPONSES FROM /API/STATUS ENDPOINTS IN SWAPPED APPS
  - stage: Check_QA
    displayName: Status Checks > QA
    dependsOn:
      - Swap_QA
      - Determine_Changes
    condition: succeeded()
    variables:
      runTerraformQA: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_TERRAFORM_QA']]
      runCodebaseQA: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_CODEBASE_QA']]
    pool:
      name: $(qa-build-agent)
    jobs:
      - job: LogStart
        displayName: Log Start
        condition: and(succeeded(), or(eq(variables.runTerraformQA, 'true'),eq(variables.runCodebaseQA, 'true')))
        steps:
          - template: tasks/task_log-start.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "QA"
              targetName: "Status Checks"
              appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"

      - job: GetStatusURIs
        dependsOn: LogStart
        condition: and(succeeded(), or(eq(variables.runTerraformQA, 'true'),eq(variables.runCodebaseQA, 'true')))
        steps:
          - template: tasks/task_check-statuses.yml
            parameters:
              targetBuild: PolarisBuild
              targetSuffix: "-qa"
              targetLabel: "QA"
              statusCheckMethod: $(status-check-method)
              statusCheckRetries: $(status-check-retries)
              statusCheckDelaySeconds: $(status-check-delay-seconds)
              statusCheckTimeoutSeconds: $(status-check-timeout-seconds)
              armClientId: $(innovation-qa-spn-client-id)
              armClientSecret: $(innovation-qa-spn-secret)
              armTenantId: $(innovation-qa-spn-tenant-id)
              armSubscriptionId: $(innovation-qa-subscription-id)

      - job: LogResult
        condition: and(succeeded(), or(eq(variables.runTerraformQA, 'true'),eq(variables.runCodebaseQA, 'true')))
        dependsOn:
          - LogStart
          - GetStatusURIs
          - CheckCoordinator
          - CheckPDFGenerator
          - CheckTextExtractor
          - CheckGateway
          - CheckSPA
        steps:
          - template: tasks/task_log-result.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "QA"
              targetName: "Status Checks"
              appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"
              devOpsPatToken: "$(devops-pat-token)"

  # QA: SAVE COMMIT REPORTS TO THE PIPELINE REPO          
  - stage: Create_Commit_Report_QA
    displayName: Save Report > QA
    dependsOn:
      - Check_QA
      - Determine_Changes
    condition: succeeded()
    variables:
      runTerraformQA: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_TERRAFORM_QA']]
      runCodebaseQA: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_CODEBASE_QA']]
    pool:
      name: $(qa-build-agent)
    jobs:
      - job: LogStart
        displayName: Log Start
        condition: and(succeeded(), or(eq(variables.runTerraformQA, 'true'),eq(variables.runCodebaseQA, 'true')))
        steps:
          - template: tasks/task_log-start.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "QA"
              targetName: "Create Commit Report"
              appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"

      - job: CreateCommitReport
        dependsOn: LogStart
        condition: and(succeeded(), or(eq(variables.runTerraformQA, 'true'),eq(variables.runCodebaseQA, 'true')))
        steps:
          - template: tasks/task_create-commit-report.yml
            parameters:
              targetLabel: "QA"
              targetLabelLower: "qa"

      - job: LogResult
        condition: and(succeeded(), or(eq(variables.runTerraformQA, 'true'),eq(variables.runCodebaseQA, 'true')))
        dependsOn:
          - LogStart
          - CreateCommitReport
        steps:
          - template: tasks/task_log-result.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "QA"
              targetName: "Create Commit Report"
              appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"
              devOpsPatToken: "$(devops-pat-token)"

  # QA: MOVE THE GITHUB TAG TO THE TIP OF MAIN          
  - stage: Update_GitHub_Tag_QA
    displayName: Update Tag > QA
    dependsOn:
      - Create_Commit_Report_QA
      - Determine_Changes
    condition: succeeded()
    variables:
      runTerraformQA: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_TERRAFORM_QA']]
      runCodebaseQA: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_CODEBASE_QA']]
    pool:
      name: $(qa-build-agent)
    jobs:
      - job: LogStart
        displayName: Log Start
        condition: and(succeeded(), or(eq(variables.runTerraformQA, 'true'),eq(variables.runCodebaseQA, 'true')))
        steps:
          - template: tasks/task_log-start.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "QA"
              targetName: "Update GitHub Tag"
              appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"

      - job: UpdateGithubTag
        dependsOn: LogStart
        steps:
          - template: tasks/task_update-github-tag.yml
            parameters:
              targetLabel: "QA"

      - job: LogResult
        condition: and(succeeded(), or(eq(variables.runTerraformQA, 'true'),eq(variables.runCodebaseQA, 'true')))
        dependsOn:
          - LogStart
          - UpdateGitHubTag
        steps:
          - template: tasks/task_log-result.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "QA"
              targetName: "Update GitHub Tag"
              appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"
              devOpsPatToken: "$(devops-pat-token)"

  #QA: RUN E2E TESTS AS FINAL CHECKS          
  - stage: Run_e2e_Tests_QA
    displayName: e2e tests > QA
    dependsOn:
      - Update_GitHub_Tag_QA
      - Determine_Changes
    condition: succeeded()
    variables:
      runTerraformQA: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_TERRAFORM_QA']]
      runCodebaseQA: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_CODEBASE_QA']]
    pool:
      name: $(qa-build-agent)
    jobs:
      - job: LogStart
        displayName: Log Start
        condition: and(succeeded(), or(eq(variables.runTerraformQA, 'true'),eq(variables.runCodebaseQA, 'true')))
        steps:
          - template: tasks/task_log-start.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "QA"
              targetName: "e2e Tests"
              appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"

      - job: RunE2ETests
        condition: and(succeeded(), or(eq(variables.runTerraformQA, 'true'),eq(variables.runCodebaseQA, 'true')))
        steps:
          - template: tasks/task_run-e2e-tests.yml
            parameters:
              targetLabel: "QA"
              buildDefinitionId: 210
              devOpsPatToken: "$(devops-pat-token)"

      - job: LogResult
        condition: and(succeeded(), or(eq(variables.runTerraformQA, 'true'),eq(variables.runCodebaseQA, 'true')))
        dependsOn:
          - LogStart
          - RunE2eTests
        steps:
          - template: tasks/task_log-result.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "QA"
              targetName: "e2e Tests"
              appInsightsKey: "$(innovation-qa-app-insights-instrumentation-key)"
              devOpsPatToken: "$(devops-pat-token)"
                        
  ################################# PROD ###############################################          
  # QUEUE PIPELINE IF ANOTHER ONE BASED ON THIS BUILD DEFINITION ID IS ALREADY RUNNING
  - stage: Wait_For_Running_Releases_PROD
    displayName: Assess Queue
    dependsOn:
      - Determine_Changes
      - Run_e2e_Tests_DEV
    condition: succeeded()
    variables:
      runTerraformPROD: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_TERRAFORM_PROD']]
      runCodebasePROD: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_CODEBASE_PROD']]
    jobs:
      # Job to wait for running builds
      - deployment: waitForRunningBuildsDev
        condition: or(eq(variables.runTerraformPROD, 'true'),eq(variables.runCodebasePROD, 'true'))
        displayName: 'Checking for Running Releases'
        timeoutInMinutes: 240
        pool:
          vmImage: 'windows-latest'
        continueOnError: false  # 'true' if future jobs should run even if this job fails; defaults to 'false'
        environment: "PROD"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_wait-for-running-releases.yml
                  parameters:
                    devOpsPatToken: "$(devops-pat-token)"

  # PROD: BEGIN DEPLOYMENT, TERRAFORM AND THEN CODEBASE, IF CHANGES FOUND  
  - stage: Deploy_PROD
    displayName: Deploy > PROD
    condition: succeeded()
    variables:
      runTerraformPROD: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_TERRAFORM_PROD']]
      runCodebasePROD: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_CODEBASE_PROD']]
    dependsOn:
      - Determine_Changes
      - Wait_For_Running_Releases_PROD
    pool:
      name: $(prod-build-agent)
    jobs:
      - deployment: LogStart
        displayName: Log Start
        condition: and(succeeded(), or(eq(variables.runTerraformPROD, 'true'),eq(variables.runTerraformPROD, 'true')))
        environment: "PROD"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_log-start-deployment.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "PROD"
                    targetName: "CI Deployment"
                    appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"

      - deployment: LogStartTerraform
        condition: and(succeeded(), eq(variables.runTerraformPROD, 'true'))
        dependsOn: LogStart
        displayName: Log Terraform Start
        environment: "PROD"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_log-start-deployment.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "PROD"
                    targetName: "Terraform CI Deployment"
                    appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"

      - deployment: ApplyNetworkingTerraform
        condition: and(succeeded(), eq(variables.runTerraformPROD, 'true'))
        displayName: Apply Networking Terraform
        dependsOn: LogStartTerraform
        environment: "PROD"
        workspace:
          clean: all
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_apply-terraform.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetTerraformArtifact: "networking-terraform-files"
                    targetLabel: "PROD"
                    targetName: "Networking Terraform CI Deployment"
                    targetPlanName: "prod"
                    appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"
                    terraformStorageAccount: $(prod-terraform-storage-account)
                    terraformContainerName: $(networking-terraform-container-name)
                    terraformStateKey: $(terraform-key)
                    terraformStateAccessKey: $(cpsprodstorageterraform-key1)
                    armClientId: $(innovation-prod-spn-client-id)
                    armClientSecret: $(innovation-prod-spn-secret)
                    armTenantId: $(innovation-prod-spn-tenant-id)
                    armSubscriptionId: $(innovation-prod-subscription-id)

      - deployment: ApplyPipelineTerraform
        condition: and(succeeded(), eq(variables.runTerraformPROD, 'true'))
        dependsOn: ApplyNetworkingTerraform
        displayName: Apply Pipeline Terraform
        environment: "PROD"
        workspace:
          clean: all
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_apply-terraform.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetTerraformArtifact: "pipeline-terraform-files"
                    targetLabel: "PROD"
                    targetName: "Pipeline Terraform CI Deployment"
                    targetPlanName: "prod"
                    appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"
                    terraformStorageAccount: $(prod-terraform-storage-account)
                    terraformContainerName: $(pipeline-terraform-container-name)
                    terraformStateKey: $(terraform-key)
                    terraformStateAccessKey: $(cpsprodstorageterraform-key1)
                    armClientId: $(innovation-prod-spn-client-id)
                    armClientSecret: $(innovation-prod-spn-secret)
                    armTenantId: $(innovation-prod-spn-tenant-id)
                    armSubscriptionId: $(innovation-prod-subscription-id)

      - deployment: ApplyPipelineEventsTerraform
        condition: and(succeeded(), eq(variables.runTerraformPROD, 'true'))
        dependsOn: ApplyNetworkingTerraform
        displayName: Apply Pipeline Events Terraform
        environment: "PROD"
        workspace:
          clean: all
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_apply-terraform.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetTerraformArtifact: "pipeline-events-terraform-files"
                    targetLabel: "PROD"
                    targetName: "Pipeline Events Terraform CI Deployment"
                    targetPlanName: "prod"
                    appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"
                    terraformStorageAccount: $(prod-terraform-storage-account)
                    terraformContainerName: $(pipeline-events-terraform-container-name)
                    terraformStateKey: $(terraform-key)
                    terraformStateAccessKey: $(cpsprodstorageterraform-key1)
                    armClientId: $(innovation-prod-spn-client-id)
                    armClientSecret: $(innovation-prod-spn-secret)
                    armTenantId: $(innovation-prod-spn-tenant-id)
                    armSubscriptionId: $(innovation-prod-subscription-id)

      - deployment: UpdatePipelineComponentAppKeys
        dependsOn: ApplyPipelineTerraform
        displayName: Update Component Keys
        condition: and(succeeded(), eq(variables.runTerraformPROD, 'true'))
        environment: "PROD"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_update-app-keys-in-pipeline-components.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "PROD"
                    targetName: "Pipeline Terraform CI Deployment"
                    targetSuffix: ""
                    appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"
                    armClientId: $(innovation-prod-spn-client-id)
                    armClientSecret: $(innovation-prod-spn-secret)
                    armTenantId: $(innovation-prod-spn-tenant-id)
                    armSubscriptionId: $(innovation-prod-subscription-id)

      - deployment: ApplyUITerraform
        condition: and(succeeded(), eq(variables.runTerraformPROD, 'true'))
        dependsOn: UpdatePipelineComponentAppKeys
        displayName: Apply UI Terraform
        environment: "PROD"
        workspace:
          clean: all
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_apply-terraform.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetTerraformArtifact: "ui-terraform-files"
                    targetLabel: "PROD"
                    targetName: "UI Terraform CI Deployment"
                    targetPlanName: "prod"
                    appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"
                    terraformStorageAccount: $(prod-terraform-storage-account)
                    terraformContainerName: $(ui-terraform-container-name)
                    terraformStateKey: $(terraform-key)
                    terraformStateAccessKey: $(cpsprodstorageterraform-key1)
                    armClientId: $(innovation-prod-spn-client-id)
                    armClientSecret: $(innovation-prod-spn-secret)
                    armTenantId: $(innovation-prod-spn-tenant-id)
                    armSubscriptionId: $(innovation-prod-subscription-id)

      - deployment: ApplyUIEventsTerraform
        condition: and(succeeded(), eq(variables.runTerraformPROD, 'true'))
        dependsOn: ApplyUITerraform
        displayName: Apply UI Events Terraform
        environment: "PROD"
        workspace:
          clean: all
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_apply-terraform.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetTerraformArtifact: "ui-events-terraform-files"
                    targetLabel: "PROD"
                    targetName: "UI Events Terraform CI Deployment"
                    targetPlanName: "prod"
                    appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"
                    terraformStorageAccount: $(prod-terraform-storage-account)
                    terraformContainerName: $(ui-events-terraform-container-name)
                    terraformStateKey: $(terraform-key)
                    terraformStateAccessKey: $(cpsprodstorageterraform-key1)
                    armClientId: $(innovation-prod-spn-client-id)
                    armClientSecret: $(innovation-prod-spn-secret)
                    armTenantId: $(innovation-prod-spn-tenant-id)
                    armSubscriptionId: $(innovation-prod-subscription-id)

      - deployment: SetLogAnalyticsArchivalPeriods
        condition: and(succeeded(), eq(variables.runTerraformPROD, 'true'))
        dependsOn: ApplyUITerraform
        displayName: Update Analytics Archival Periods
        environment: "PROD"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_set-log-analytics-archival-periods.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "PROD"
                    targetName: "UI Terraform CI Deployment"
                    targetSuffix: ""
                    appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"
                    armClientId: $(innovation-prod-spn-client-id)
                    armClientSecret: $(innovation-prod-spn-secret)
                    armTenantId: $(innovation-prod-spn-tenant-id)
                    armSubscriptionId: $(innovation-prod-subscription-id)
                    logRetentionTime: $(log-retention-time)
                    totalLogRetentionTime: $(total-log-retention-time)

      - deployment: LogResultTerraformEnded
        condition: and(succeeded(), eq(variables.runTerraformPROD, 'true'))
        displayName: Log Terraform End
        dependsOn:
          - ApplyPipelineTerraform
          - ApplyPipelineEventsTerraform
          - UpdatePipelineComponentAppKeys
          - ApplyUITerraform
          - ApplyUIEventsTerraform
          - SetLogAnalyticsArchivalPeriods
          - ApplyNetworkingTerraform
        environment: "PROD"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_log-result-deployment.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "PROD"
                    targetName: "Terraform CI Deployment"
                    appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"
                    devOpsPatToken: "$(devops-pat-token)"

      - deployment: LogStartCodebase
        condition: and(succeeded(), eq(variables.runCodebasePROD, 'true'))
        dependsOn: LogResultTerraformEnded
        displayName: Log Codebase Start
        environment: "PROD"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_log-start-deployment.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "PROD"
                    targetName: "Codebase CI Deployment"
                    appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"

      - job: StartPipelineSlots
        dependsOn: LogResultTerraformEnded
        condition: and(succeeded(), eq(variables.runCodebasePROD, 'true'))
        strategy:
          matrix:
            Coordinator:
              Name: "Coordinator"
              AppServiceName: "fa-polaris-coordinator"
            PDFGenerator:
              Name: "PDF Generator"
              AppServiceName: "fa-polaris-pdf-generator"
        displayName: Start Staging1
        steps:
          - checkout: none
          - task: AzureAppServiceManage@0
            displayName: Start Slot
            inputs:
              Action: "Start Azure App Service"
              SpecifySlotOrASE: true
              Slot: "staging1"
              azureSubscription: $(prod-azure-subscription)
              ResourceGroupName: "rg-polaris-pipeline"
              WebAppName: $(AppServiceName)

      - job: Start_UI_Slots
        dependsOn: LogResultTerraformEnded
        condition: and(succeeded(), eq(variables.runCodebasePROD, 'true'))
        strategy:
          matrix:
            SPA:
              Name: "SPA"
              AppServiceName: "as-web-polaris"
            PolarisGateway:
              Name: "Polaris Gateway"
              AppServiceName: "fa-polaris-gateway"
        displayName: Start Staging1
        steps:
          - checkout: none
          - task: AzureAppServiceManage@0
            displayName: Start slot
            inputs:
              Action: "Start Azure App Service"
              SpecifySlotOrASE: true
              Slot: "staging1"
              azureSubscription: $(prod-azure-subscription)
              ResourceGroupName: "rg-polaris"
              WebAppName: $(AppServiceName)

      - deployment: DeployCoordinator
        dependsOn: Start_Pipeline_Slots
        displayName: Deploy Coordinator
        condition: and(succeeded(), eq(variables.runCodebasePROD, 'true'))
        environment: "PROD"
        workspace:
          clean: all
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_deploy-coordinator.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "PROD"
                    targetSuffix: ""
                    appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"
                    azureSubscription: $(prod-azure-subscription)

      - deployment: DeployPdfGenerator
        dependsOn: Start_Pipeline_Slots
        displayName: Deploy PDF Generator
        condition: and(succeeded(), eq(variables.runCodebasePROD, 'true'))
        environment: "PROD"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_deploy-pdf-generator.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "PROD"
                    targetSuffix: ""
                    appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"
                    azureSubscription: $(prod-azure-subscription)

      - deployment: DeployTextGenerator
        dependsOn: Start_Pipeline_Slots
        displayName: Deploy Text Extractor
        condition: and(succeeded(), eq(variables.runCodebasePROD, 'true'))
        environment: "PROD"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_deploy-text-extractor.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "PROD"
                    targetSuffix: ""
                    appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"
                    azureSubscription: $(prod-azure-subscription)

      - deployment: DeploySpa
        dependsOn: Start_UI_Slots
        displayName: Deploy SPA
        condition: and(succeeded(), eq(variables.runCodebasePROD, 'true'))
        environment: "PROD"
        workspace:
          clean: all
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_deploy-spa.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "PROD"
                    targetSuffix: ""
                    appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"
                    azureSubscription: $(prod-azure-subscription)

      - deployment: DeployGateway
        dependsOn: Start_UI_Slots
        displayName: Deploy Gateway
        condition: and(succeeded(), eq(variables.runCodebasePROD, 'true'))
        environment: "PROD"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_deploy-gateway.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "PROD"
                    targetSuffix: ""
                    appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"
                    azureSubscription: $(prod-azure-subscription)

      - deployment: LogResultCodebaseEnded
        condition: and(succeeded(), eq(variables.runCodebasePROD, 'true'))
        displayName: Log Codebase End
        dependsOn:
          - DeployCoordinator
          - DeployPdfGenerator
          - DeployTextGenerator
          - DeploySpa
          - DeployGateway
        environment: "PROD"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_log-result-deployment.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "PROD"
                    targetName: "Codebase CI Deployment"
                    appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"
                    devOpsPatToken: "$(devops-pat-token)"

      - deployment: LogResultEnded
        condition: and(succeeded(), or(eq(variables.runTerraformPROD, 'true'),eq(variables.runCodebasePROD, 'true')))
        displayName: Log Deployment End
        dependsOn:
          - ApplyPipelineTerraform
          - ApplyPipelineEventsTerraform
          - UpdatePipelineComponentAppKeys
          - ApplyUITerraform
          - ApplyUIEventsTerraform
          - SetLogAnalyticsArchivalPeriods
          - ApplyNetworkingTerraform
          - DeployCoordinator
          - DeployPdfGenerator
          - DeployTextGenerator
          - DeploySpa
          - DeployGateway
        environment: "PROD"
        strategy:
          runOnce:
            deploy:
              steps:
                - template: tasks/task_log-result-deployment.yml
                  parameters:
                    targetBuild: PolarisBuild
                    targetLabel: "PROD"
                    targetName: "CI Deployment"
                    appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"
                    devOpsPatToken: "$(devops-pat-token)"

  # PROD: BEGIN SLOT SWAP PROCESS
  - stage: Swap_PROD
    displayName: Swap Slots > PROD
    dependsOn:
      - Deploy_PROD
      - Determine_Changes
    variables:
      runCodebasePROD: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_CODEBASE_PROD']]
    condition: succeeded()
    pool:
      name: $(prod-build-agent)
    jobs:
      - job: LogStart
        displayName: Log Start
        condition: and(succeeded(), eq(variables.runCodebasePROD, 'true'))
        steps:
          - template: tasks/task_log-start.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "PROD"
              targetName: "Swap Polaris Codebase Slots"
              appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"

      - job: Pause_Pipeline
        dependsOn: LogStart
        condition: and(succeeded(), eq(variables.runCodebasePROD, 'true'))
        displayName: Pause for 2 mins
        steps:
          - template: tasks/task_pause-pipeline.yml

      - job: Start_Pipeline_Slots
        dependsOn: Pause_Pipeline
        condition: and(succeeded(), eq(variables.runCodebasePROD, 'true'))
        strategy:
          matrix:
            Coordinator:
              Name: "Coordinator"
              AppServiceName: "fa-polaris-coordinator"
            PDFGenerator:
              Name: "PDF Generator"
              AppServiceName: "fa-polaris-pdf-generator"
        displayName: Start Staging1
        steps:
          - checkout: none
          - task: AzureAppServiceManage@0
            displayName: Start Slot
            inputs:
              Action: "Start Azure App Service"
              SpecifySlotOrASE: true
              Slot: "staging1"
              azureSubscription: $(prod-azure-subscription)
              ResourceGroupName: "rg-polaris-pipeline"
              WebAppName: $(AppServiceName)

      - job: Start_UI_Slots
        dependsOn: Pause_Pipeline
        condition: and(succeeded(), eq(variables.runCodebasePROD, 'true'))
        strategy:
          matrix:
            SPA:
              Name: "SPA"
              AppServiceName: "as-web-polaris"
            PolarisGateway:
              Name: "Polaris Gateway"
              AppServiceName: "fa-polaris-gateway"
        displayName: Start Staging1
        steps:
          - checkout: none
          - task: AzureAppServiceManage@0
            displayName: Start slot
            inputs:
              Action: "Start Azure App Service"
              SpecifySlotOrASE: true
              Slot: "staging1"
              azureSubscription: $(prod-azure-subscription)
              ResourceGroupName: "rg-polaris"
              WebAppName: $(AppServiceName)

      - job: Swap_Pipeline_Slots
        dependsOn: Start_Pipeline_Slots
        condition: and(succeeded(), eq(variables.runCodebasePROD, 'true'))
        strategy:
          matrix:
            Coordinator:
              Name: "Coordinator"
              AppServiceName: "fa-polaris-coordinator"
            PDFGenerator:
              Name: "PDF Generator"
              AppServiceName: "fa-polaris-pdf-generator"
        displayName: Swap
        steps:
          - checkout: none
          - task: AzureAppServiceManage@0
            displayName: Swap slot
            inputs:
              action: "Swap Slots"
              sourceSlot: "staging1"
              azureSubscription: $(prod-azure-subscription)
              resourceGroupName: "rg-polaris-pipeline"
              webAppName: $(AppServiceName)
              PreserveVnet: true

      - job: Swap_UI_Slots
        dependsOn: Start_UI_Slots
        condition: and(succeeded(), eq(variables.runCodebasePROD, 'true'))
        strategy:
          matrix:
            SPA:
              Name: "SPA"
              AppServiceName: "as-web-polaris"
            PolarisGateway:
              Name: "Polaris Gateway"
              AppServiceName: "fa-polaris-gateway"
        displayName: Swap
        steps:
          - checkout: none
          - task: AzureAppServiceManage@0
            displayName: Swap slot
            inputs:
              action: "Swap Slots"
              sourceSlot: "staging1"
              azureSubscription: $(prod-azure-subscription)
              resourceGroupName: "rg-polaris"
              webAppName: $(AppServiceName)
              PreserveVnet: true

      - job: LogResult
        condition: and(succeeded(), eq(variables.runCodebasePROD, 'true'))
        dependsOn:
          - Swap_Pipeline_Slots
          - Swap_UI_Slots
        steps:
          - template: tasks/task_log-result.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "PROD"
              targetName: "Swap Polaris Codebase Slots"
              appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"
              devOpsPatToken: "$(devops-pat-token)"

  # PROD: CHECK FOR VALID STATUS RESPONSES FROM /API/STATUS ENDPOINTS IN SWAPPED APPS
  - stage: Check_PROD
    displayName: Status Checks > PROD
    dependsOn:
      - Swap_PROD
      - Determine_Changes
    condition: succeeded()
    variables:
      runTerraformPROD: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_TERRAFORM_PROD']]
      runCodebasePROD: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_CODEBASE_PROD']]
    pool:
      name: $(prod-build-agent)
    jobs:
      - job: LogStart
        displayName: Log Start
        condition: and(succeeded(), or(eq(variables.runTerraformPROD, 'true'),eq(variables.runCodebasePROD, 'true')))
        steps:
          - template: tasks/task_log-start.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "PROD"
              targetName: "Status Checks"
              appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"

      - job: GetStatusURIs
        dependsOn: LogStart
        condition: and(succeeded(), or(eq(variables.runTerraformPROD, 'true'),eq(variables.runCodebasePROD, 'true')))
        steps:
          - template: tasks/task_check-statuses.yml
            parameters:
              targetBuild: PolarisBuild
              targetSuffix: ""
              targetLabel: "PROD"
              statusCheckMethod: $(status-check-method)
              statusCheckRetries: $(status-check-retries)
              statusCheckDelaySeconds: $(status-check-delay-seconds)
              statusCheckTimeoutSeconds: $(status-check-timeout-seconds)
              armClientId: $(innovation-prod-spn-client-id)
              armClientSecret: $(innovation-prod-spn-secret)
              armTenantId: $(innovation-prod-spn-tenant-id)
              armSubscriptionId: $(innovation-prod-subscription-id)

      - job: LogResult
        condition: and(succeeded(), or(eq(variables.runTerraformPROD, 'true'),eq(variables.runCodebasePROD, 'true')))
        dependsOn:
          - LogStart
          - GetStatusURIs
          - CheckCoordinator
          - CheckPDFGenerator
          - CheckTextExtractor
          - CheckGateway
          - CheckSPA
        steps:
          - template: tasks/task_log-result.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "PROD"
              targetName: "Status Checks"
              appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"
              devOpsPatToken: "$(devops-pat-token)"

  # PROD: SAVE COMMIT REPORTS TO THE PIPELINE REPO          
  - stage: Create_Commit_Report_PROD
    displayName: Save Report > PROD
    dependsOn:
      - Check_PROD
      - Determine_Changes
    condition: succeeded()
    variables:
      runTerraformPROD: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_TERRAFORM_PROD']]
      runCodebasePROD: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_CODEBASE_PROD']]
    pool:
      name: $(prod-build-agent)
    jobs:
      - job: LogStart
        displayName: Log Start
        condition: and(succeeded(), or(eq(variables.runTerraformPROD, 'true'),eq(variables.runCodebasePROD, 'true')))
        steps:
          - template: tasks/task_log-start.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "PROD"
              targetName: "Create Commit Report"
              appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"

      - job: CreateCommitReport
        dependsOn: LogStart
        condition: and(succeeded(), or(eq(variables.runTerraformPROD, 'true'),eq(variables.runCodebasePROD, 'true')))
        steps:
          - template: tasks/task_create-commit-report.yml
            parameters:
              targetLabel: "PROD"
              targetLabelLower: "prod"

      - job: LogResult
        condition: and(succeeded(), or(eq(variables.runTerraformPROD, 'true'),eq(variables.runCodebasePROD, 'true')))
        dependsOn:
          - LogStart
          - CreateCommitReport
        steps:
          - template: tasks/task_log-result.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "PROD"
              targetName: "Create Commit Report"
              appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"
              devOpsPatToken: "$(devops-pat-token)"

  # PROD: MOVE THE GITHUB TAG TO THE TIP OF MAIN          
  - stage: Update_GitHub_Tag_PROD
    displayName: Update Tag > PROD
    dependsOn:
      - Create_Commit_Report_PROD
      - Determine_Changes
    condition: succeeded()
    variables:
      runTerraformPROD: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_TERRAFORM_PROD']]
      runCodebasePROD: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_CODEBASE_PROD']]
    pool:
      name: $(prod-build-agent)
    jobs:
      - job: LogStart
        displayName: Log Start
        condition: and(succeeded(), or(eq(variables.runTerraformPROD, 'true'),eq(variables.runCodebasePROD, 'true')))
        steps:
          - template: tasks/task_log-start.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "PROD"
              targetName: "Update GitHub Tag"
              appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"

      - job: UpdateGithubTag
        dependsOn: LogStart
        steps:
          - template: tasks/task_update-github-tag.yml
            parameters:
              targetLabel: "PROD"

      - job: LogResult
        condition: and(succeeded(), or(eq(variables.runTerraformPROD, 'true'),eq(variables.runCodebasePROD, 'true')))
        dependsOn:
          - LogStart
          - UpdateGitHubTag
        steps:
          - template: tasks/task_log-result.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "PROD"
              targetName: "Update GitHub Tag"
              appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"
              devOpsPatToken: "$(devops-pat-token)"

  #PROD: RUN E2E TESTS AS FINAL CHECKS          
  - stage: Run_e2e_Tests_PROD
    displayName: e2e tests > PROD
    dependsOn:
      - Update_GitHub_Tag_PROD
      - Determine_Changes
    condition: succeeded()
    variables:
      runTerraformPROD: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_TERRAFORM_PROD']]
      runCodebasePROD: $[stageDependencies.Determine_Changes.Generate_Diff.outputs['Change_Results.RUN_CODEBASE_PROD']]
    pool:
      name: $(prod-build-agent)
    jobs:
      - job: LogStart
        displayName: Log Start
        condition: and(succeeded(), or(eq(variables.runTerraformPROD, 'true'),eq(variables.runCodebasePROD, 'true')))
        steps:
          - template: tasks/task_log-start.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "PROD"
              targetName: "e2e Tests"
              appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"

      - job: RunE2ETests
        condition: and(succeeded(), or(eq(variables.runTerraformPROD, 'true'),eq(variables.runCodebasePROD, 'true')))
        steps:
          - template: tasks/task_run-e2e-tests.yml
            parameters:
              targetLabel: "PROD"
              buildDefinitionId: 210
              devOpsPatToken: "$(devops-pat-token)"

      - job: LogResult
        condition: and(succeeded(), or(eq(variables.runTerraformPROD, 'true'),eq(variables.runCodebasePROD, 'true')))
        dependsOn:
          - LogStart
          - RunE2eTests
        steps:
          - template: tasks/task_log-result.yml
            parameters:
              targetBuild: PolarisBuild
              targetLabel: "PROD"
              targetName: "e2e Tests"
              appInsightsKey: "$(innovation-prod-app-insights-instrumentation-key)"
              devOpsPatToken: "$(devops-pat-token)"